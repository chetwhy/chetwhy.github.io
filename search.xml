<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Map之HashMap源码浅析-扩容]]></title>
    <url>%2F2019%2F04%2F20%2FMap%E4%B9%8BHashMap%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[HashMap源码浅析 jdk11，工具idea 一、存储结构入口：Ctrl+N查找到hashmap源码，找到静态内部类 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Basic hash bin node, used for most entries. (See below for * TreeNode subclass, and in LinkedHashMap for its Entry subclass.) */static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + "=" + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125;&#125; 初始化时，为一个Node类型的数组，每个元素为一组键值对。 1234567/** * The table, initialized on first use, and resized as * necessary. When allocated, length is always a power of two. * (We also tolerate length zero in some operations to allow * bootstrapping mechanics that are currently not needed.) */transient Node&lt;K,V&gt;[] table; 从静态类中的next可以看出，Node为链表结构。即Node数组的每个元素(也可称为桶)都可存储一个链表。 从 JDK 1.8 开始，一个桶存储的链表长度大于 8 时会将链表转换为红黑树。 二、拉链法1. 源码跟踪示例：创建一个hashmap，放入3个键值对。 新建一个HashMap，默认大小为16，且都为2的幂。 1234/** * The default initial capacity - MUST be a power of two. */static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 将map中放入3个键值对。 12345678@Testpublic void testHashMapHashCode() &#123; HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put("K1", "V1"); // hash=2374 map.put("K2", "V2"); map.put("K3", "V3"); System.out.println(map.get("K1").hashCode());&#125; 12715 存入map的键值的哈希值并不等于取出时的哈希值 确定桶的下表位置(即数组下标)，跟踪put(k,v)源码： 存入K1,V1 123public V put(K key, V value) &#123; // K1,V1 return putVal(hash(key), key, value, false, true);&#125; 计算k1的hash=2374 12345static final int hash(Object key) &#123; // k1 int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); // hash=2374&#125; put操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 参数=2374,k1,v1,false,truefinal V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 16 // 计算出桶的索引 // 如果table的在（n-1）&amp;hash的值是空，就新建一个节点插入在该位置 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); // i=6 // 冲突 else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) // 红黑树 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; // 指针为空就挂在后面 p.next = newNode(hash, key, value, null); // 如果冲突的节点数达到8个 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st // 如果tab为空或小于64--&gt;resize() // 大于64转为红黑树结构replacementTreeNode treeifyBin(tab, hash); break; &#125; // 如果有相同的key值就结束遍历 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; // 链表上有相同的key值 if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; // 大于门限threshold (capacity * load factor) if (++size &gt; threshold) resize(); // 扩容 afterNodeInsertion(evict); return null;&#125; 后续操作很多源码从putVal展开 注意索引的取值方法 i = (n - 1) &amp; hash，表示该位置原来没有桶时，新链表的位置 K1,K2,K3存入的hash值分别为2374，2375，2376，对应的下标依次为6，7，8 2. put方法2.1 头插法当桶下标相同时，后一个put的KV对插在前一个KV对的前面，即新链表插在旧链表的头部。 步骤： 计算K所在的桶下标 确定桶后，在链表在顺序查找，时间复杂度与链表长度成正比。 2.2 null值在计算hash值时，空值处理 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);即hashmap可以插入null值，但null没有hashCode()方法，就无法计算桶下标，因此以第0个桶确定为null的位置。 3. 扩容如何理解算法时间复杂度的表示法 假设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N/M，因此平均查找次数的复杂度为 O(N/M)。 为了降低复杂度，需要N/M尽可能大，因此M尽可能大。HashMap根据键(N)的数量动态调整table数组(M，Node&lt;K,V&gt;[] table)的长度，即动态扩容。 满足++size &gt; threshold条件时，进行扩容，调用resize()方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * Initializes or doubles table size. If null, allocates in * accord with initial capacity target held in field threshold. * Otherwise, because we are using power-of-two expansion, the * elements from each bin must either stay at same index, or move * with a power of two offset in the new table. */final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; // 旧表不为空 if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold 旧表的两倍 &#125; // 旧表的长度的是0 else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; //新表长度乘以加载因子 float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; // 构造新表 @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; // 旧表不为空，遍历并复制到新表 if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 扩容时须要拷贝旧表到新表，因此很耗时 为提高扩容性能，处理碰撞，jdk1.8后，一个桶存储的链表长度大于 8 时会将链表转换为红黑树 12345678910111213141516171819202122232425262728293031/** * Replaces all linked nodes in bin at index for given hash unless * table is too small, in which case resizes instead. */final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123; int n, index; Node&lt;K,V&gt; e; if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) resize(); else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123; TreeNode&lt;K,V&gt; hd = null, tl = null; do &#123; TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null); ....../** * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn * extends Node) so can be used as extension of either regular or * linked node. */static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123; // 父节点 TreeNode&lt;K,V&gt; parent; // red-black tree links // 左子树 TreeNode&lt;K,V&gt; left; TreeNode&lt;K,V&gt; right; TreeNode&lt;K,V&gt; prev; // needed to unlink next upon deletion boolean red; TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123; super(hash, key, val, next); &#125;....]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot之全局异常处理]]></title>
    <url>%2F2019%2F04%2F20%2FSpringBoot%E4%B9%8B%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[异常处理问题分析异常如何处理问题引入针对代码中的异常，常规有两种处理方式，一种throws直接抛出，另一种try..catch捕获。 在java项目中，有可能存在人为逻辑的异常，也可能为取得异常的详情，或是保证程序在异常时继续向下执行，会采用第二种处理方式。 但是，代码中每一处异常都来捕获，会使代码什么冗余且不利于维护。 解决思路定义一个全局异常处理类，返回统一规范的异常信息； 处理逻辑是，先判定是否会出现异常，再执行后续具体的业务。 业务举例本文主要为了实现全局异常处理的逻辑，只举简单业务 某公司部门需增加员工，处理流程：1先根据员工编号查询员工对象，2判断员工对象是否有信息，即是否不为空，3若有信息，则说明已存在，无需再添加，若不是，则直接添加。 代码如下： 12345678910111213141516171819202122public class MyService &#123; // 注入dao层 @Autowired EmployeeecMapper employeeecMapper; /** * 添加员工信息 * @param employee 员工对象 * @return 影响的行数 */ public int add(Employee employee) &#123; // 根据id查询员工对象 Employeeec emp = employeeecMapper.selectByPrimaryKey(employee.getId()); // 判断是否已有该员工 if (emp != null)&#123; // 已有，抛出异常，异常信息为已有该员工 throw new RuntimeException("异常代码：1201，错误信息：该员工已存在"); &#125; // 没有，插入该员工 return employeeecMapper.insert(emp); &#125;&#125; 异常处理流程业务中存在运行时异常和业务逻辑异常，前者不运行时很难察觉，后者在遍及业务时就可以定义出来，因此异常分为不可预知异常和可知异常。流程如下： 自定义全局异常类，使用@ControllerAdvice，控制器增强 自定义错误代码及错误信息，两种异常最终会采用统一的信息格式来表示，错误代码+错误信息。 对于可预知的异常由程序员在代码中主动抛出，由SpringMVC统一捕获。 不可预知异常通常是由于系统出现bug、或一些外界因素（如网络波动、服务器宕机等），异常类型为RuntimeException类型（运行时异常）。 可知异常定义异常信息类，变量为错误代码和错误信息，捕获自定义异常时，直接将该对象返回 不可知异常定义一个map，将常见的异常存入其中，并定义错误代码。对于其他不常见的异常，即map中没有的，同一一个异常对象返回即可。 异常处理代码流程可知异常1、定义打印异常信息与返回结果的接口 12345678910public interface ResultCode &#123; // 操作是否成功 boolean success(); // 操作结果代码 long code(); // 提示信息 String message();&#125; 1234public interface Response &#123; public static final boolean SUCCESS = true; public static final int SUCCESS_CODE = 10000;&#125; 2、定义打印异常信息的枚举类和返回结果类 123456789101112131415161718192021222324252627282930313233@ToStringpublic enum CommonCode implements ResultCode &#123; NO_PAGE(false,404,"没有信息"), FAIL(false,500,"操作失败！"), SUCCESS(true,200,"操作成功！"); // 结果信息 boolean success; long code; String message; // 带参构造 CommonCode(boolean success, long code, String message) &#123; this.success = success; this.code = code; this.message = message; &#125; @Override public boolean success() &#123; return true; &#125; @Override public long code() &#123; return code; &#125; @Override public String message() &#123; return message; &#125;&#125; 12345678910111213141516@Data@ToStringpublic class ResponseResult implements Response &#123; boolean success = SUCCESS; long code = SUCCESS_CODE; String message; public ResponseResult(ResultCode resultCode)&#123; this.success = resultCode.success(); this.code = resultCode.code(); this.message = resultCode.message(); &#125;&#125; 3、定义错误异常类 123456789101112131415public class CustomException extends RuntimeException&#123; @Autowired ResultCode resultCode; // 带参构造 public CustomException(ResultCode resultCode)&#123; this.resultCode = resultCode; &#125; // getter public ResultCode getResultCode()&#123; return resultCode; &#125;&#125; 4、定义异常抛出类 1234567public class ExceptionCast &#123; // 静态方法 public static void cast(ResultCode resultCode)&#123; throw new CustomException(resultCode); &#125;&#125; 5、定义异常捕获类，使用ControllerAdvice控制器增强的注解，并在捕获CustomException异常的方法上加ExceptionHandler注解，即可捕获该类的所有异常，返回json数据。 123456789101112131415@ControllerAdvice public class ExceptionCatch &#123; /** * 捕获CustomException类异常 * @param customException * @return 结果信息,json数据 */ @ExceptionHandler(CustomException.class) @ResponseBody public ResponseResult customException(CustomException customException)&#123; ResultCode resultCode = customException.getResultCode(); return new ResponseResult(resultCode); &#125;&#125; 6、在业务中抛出异常 12345678910111213public class MyService &#123; @Autowired EmployeeecMapper employeeecMapper; public int add(Employee employee) &#123; Employeeec emp = employeeecMapper.selectByPrimaryKey(employee.getId()); if (emp != null)&#123; ExceptionCast.cast(CommonCode.FAIL); &#125; return employeeecMapper.insert(emp); &#125;&#125; 不可知异常处理1、类似可知异常，先添加错误代码，如 1UNAUTHORISE(false,510,"没有权限"), 2、在异常捕获类中添加不可知异常的捕获方法。该方法中，定义一个只读的map存储异常类型的错误代码的映射，map中没有的元素，同一用错误代码999来定义。 1UNKNOWNERROR(false,999,"未知异常"), 12345678910111213141516171819202122232425262728293031323334353637383940@ControllerAdvicepublic class ExceptionCatch &#123; // 定义map，存贮常见错误信息。该类map不可修改 private static ImmutableMap&lt;Class&lt;? extends Throwable&gt;,ResultCode&gt; EXCEPTIONS; // 构建ImmutableMap protected static ImmutableMap.Builder&lt;Class&lt;? extends Throwable&gt;,ResultCode&gt; builder = ImmutableMap.builder(); @ExceptionHandler(CustomException.class) @ResponseBody public ResponseResult customException(CustomException customException)&#123; ResultCode resultCode = customException.getResultCode(); return new ResponseResult(resultCode); &#125; /** * 捕获非自定义类异常 * @param exception * @return */ @ExceptionHandler(Exception.class) @ResponseBody public ResponseResult exception(Exception exception)&#123; // 记录日志 LOGGER.error("catch exception ==&gt; ",exception.getMessage()); if (EXCEPTIONS == null)&#123; EXCEPTIONS = builder.build(); &#125; ResultCode resultCode = EXCEPTIONS.get(exception.getClass()); if (resultCode != null)&#123; return new ResponseResult(resultCode); &#125;else &#123; return new ResponseResult(CommonCode.UNKNOWNERROR); &#125; &#125; static &#123; builder.put(HttpMessageNotReadableException.class, CommonCode.INVALID_PARAM); &#125;&#125; 完成~~ 不可知异常处理###]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>异常</tag>
        <tag>控制器增强</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文章标题]]></title>
    <url>%2F2019%2F04%2F20%2F%E6%96%87%E7%AB%A0%E6%A0%87%E9%A2%98%2F</url>
    <content type="text"><![CDATA[你好你好你好csdn 12345678@Overridepublic Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; List&lt;SimpleGrantedAuthority&gt; authorities = new ArrayList&lt;&gt;(); for (Role role : roles) &#123; authorities.add(new SimpleGrantedAuthority(role.getName())); &#125; return authorities;&#125;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F20%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
